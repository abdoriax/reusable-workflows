name: Build Docker, Update Manifests for Argo CD on Tag

on:
  workflow_call:
    inputs:
      triggering_ref:
        description: 'The git ref name (e.g., v1.0.0, v1.0.0-alpha, or a simulated tag for testing) that is initiating the process. Used for tag parsing and Docker metadata.'
        required: true
        type: string
      source_checkout_ref:
        description: 'The git ref (branch, tag, or SHA) to checkout for building the application. Defaults to the value of triggering_ref if not specified.'
        required: false
        type: string

permissions:
  contents: write
  packages: write

jobs:
  build_and_push_docker_image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image_meta_output.outputs.version }}
      image_name: ghcr.io/${{ github.repository_owner }}/${{ env.REPO_NAME }}
    env:
      REPO_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ env.REPO_NAME }}
          tags: |
            type=ref,event=tag

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./app
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image tag output
        id: image_meta_output
        run: echo "version=${{ steps.meta.outputs.version }}" >> $GITHUB_OUTPUT

  update_manifest:
    name: Update Manifest for ${{ matrix.target_env }}
    needs: build_and_push_docker_image
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target_env: [development, staging, production]
    
    environment:
      name: ${{ matrix.target_env }}

    if: |
      (matrix.target_env == 'development' && contains(github.ref_name, 'alpha')) ||
      (matrix.target_env == 'staging' && contains(github.ref_name, 'beta')) ||
      (matrix.target_env == 'production' && !contains(github.ref_name, 'alpha') && !contains(github.ref_name, 'beta'))
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          yq --version

      - name: Set environment-specific variables
        id: env_specifics
        run: |
          TARGET_ENV_NAME="${{ matrix.target_env }}"
          MANIFEST_FILE_PATH=""
          COMMIT_MESSAGE_ENV_SLUG=""

          if [ "$TARGET_ENV_NAME" == "development" ]; then
            MANIFEST_FILE_PATH="./k8s/overlays/development/deployment.yaml"
            COMMIT_MESSAGE_ENV_SLUG="dev"
          elif [ "$TARGET_ENV_NAME" == "staging" ]; then
            MANIFEST_FILE_PATH="./k8s/overlays/staging/deployment.yaml"
            COMMIT_MESSAGE_ENV_SLUG="staging"
          elif [ "$TARGET_ENV_NAME" == "production" ]; then
            MANIFEST_FILE_PATH="./k8s/overlays/production/deployment.yaml"
            COMMIT_MESSAGE_ENV_SLUG="production"
          else
            echo "Error: Unknown target_env: $TARGET_ENV_NAME"
            exit 1
          fi
          echo "MANIFEST_FILE=${MANIFEST_FILE_PATH}" >> $GITHUB_OUTPUT
          echo "COMMIT_SLUG=${COMMIT_MESSAGE_ENV_SLUG}" >> $GITHUB_OUTPUT

      - name: Update Kubernetes Manifest
        env:
          MANIFEST_FILE: ${{ steps.env_specifics.outputs.MANIFEST_FILE }}
          NEW_IMAGE_WITH_TAG: "${{ needs.build_and_push_docker_image.outputs.image_name }}:${{ needs.build_and_push_docker_image.outputs.image_tag }}"
        run: |
          echo "Triggering Git tag: ${{ github.ref_name }}"
          echo "Target environment: ${{ matrix.target_env }}"
          echo "Updating manifest $MANIFEST_FILE with image $NEW_IMAGE_WITH_TAG"
          
          if [ ! -f "$MANIFEST_FILE" ]; then
            echo "Error: Manifest file $MANIFEST_FILE not found!"
            exit 1
          fi

          if ! yq e '.spec.template.spec.containers[0]' "$MANIFEST_FILE" > /dev/null; then
            echo "Error: No container found at .spec.template.spec.containers[0] in $MANIFEST_FILE"
            exit 1
          fi
          
          yq e '.spec.template.spec.containers[0].image = strenv(NEW_IMAGE_WITH_TAG)' -i "$MANIFEST_FILE"
          echo "Manifest content after update for ${{ matrix.target_env }}:"
          cat "$MANIFEST_FILE"

      - name: Commit and Push Manifest Changes
        env:
          MANIFEST_FILE: ${{ steps.env_specifics.outputs.MANIFEST_FILE }}
          GIT_COMMIT_MESSAGE: "Update ${{ steps.env_specifics.outputs.COMMIT_SLUG }} deployment image to ${{ needs.build_and_push_docker_image.outputs.image_tag }}"
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add "$MANIFEST_FILE"
          
          if git diff --staged --quiet; then
            echo "No changes to commit to $MANIFEST_FILE for ${{ matrix.target_env }}."
          else
            git commit -m "${{ env.GIT_COMMIT_MESSAGE }}"
            git push origin main # Pushing changes to 'main' branch, as in your original workflow
            echo "Pushed manifest changes for ${{ matrix.target_env }} to 'main' branch."
          fi
